{
  "master": {
    "tasks": [
      {
        "id": 0,
        "title": "專案初始化：環境變數與本地 HTTPS 設定",
        "description": "建立專案的環境變數管理機制，並為本地開發環境設定 HTTPS。此為專案的基礎，確保開發與部署的一致性，並滿足 WebRTC 對安全連線的要求。",
        "details": "此任務包含安裝 `dotenv` 來管理環境變數（如埠號、資料庫路徑），並使用 `mkcert` 或類似工具為 `localhost` 產生受信任的 SSL 憑證。後端 Express 伺服器和前端 Vite 開發伺服器都需配置為使用此憑證以啟用 HTTPS。",
        "testStrategy": "啟動後端與前端伺服器後，使用瀏覽器訪問前端頁面，確認是以 `https://` 開頭且無安全警告。檢查伺服器日誌，確認從 `.env` 檔案讀取的環境變數已正確應用。",
        "priority": "critical",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "設定環境變數管理",
            "description": "安裝並設定 `dotenv` 套件，建立 `.env` 檔案來儲存敏感或環境特定的設定值。",
            "dependencies": [],
            "details": "執行 `npm install dotenv`。在專案根目錄建立 `.env` (用於本地開發，不提交至 Git) 和 `.env.example` (作為範本提交) 檔案。在 `server.js` 的最頂部引入並配置 `dotenv`：`require('dotenv').config();`。",
            "status": "done",
            "testStrategy": "在 `.env` 中設定 `PORT=8443`，啟動伺服器，確認其監聽的是 8443 埠而非預設值。"
          },
          {
            "id": 2,
            "title": "產生本地 SSL 憑證",
            "description": "使用 `mkcert` 或 OpenSSL 等工具，為本地開發環境 (`localhost`) 產生 SSL 憑證和私鑰檔案。",
            "dependencies": [],
            "details": "安裝 `mkcert`。執行 `mkcert -install` 將本地 CA 安裝到系統信任庫。執行 `mkcert localhost` 來產生 `localhost.pem` (憑證) 和 `localhost-key.pem` (私鑰) 檔案。",
            "status": "done",
            "testStrategy": "檢查專案目錄中是否已成功生成憑證和私鑰檔案。"
          },
          {
            "id": 3,
            "title": "設定後端 Express 伺服器為 HTTPS",
            "description": "修改後端伺服器的啟動邏輯，使其使用產生的 SSL 憑證來建立一個 `https` 伺服器，而非 `http`。",
            "dependencies": [
              0.2
            ],
            "details": "引入 Node.js 的 `https` 和 `fs` 模組。讀取憑證和私鑰檔案。使用 `https.createServer({ key: privateKey, cert: certificate }, app)` 來建立伺服器實例，並將其傳遞給 WebSocket 伺服器。",
            "status": "done",
            "testStrategy": "啟動後端伺服器，使用 `curl -k https://localhost:8443` 或瀏覽器訪問，確認連線成功。"
          },
          {
            "id": 4,
            "title": "設定前端 Vite 開發伺服器為 HTTPS",
            "description": "修改 Vite 的設定檔，使其開發伺服器也以 HTTPS 模式運行，以避免混合內容錯誤。",
            "dependencies": [
              0.2
            ],
            "details": "在 `vite.config.ts` 中，加入 `server: { https: { key: fs.readFileSync('./localhost-key.pem'), cert: fs.readFileSync('./localhost.pem') } }` 設定。",
            "status": "done",
            "testStrategy": "執行 `npm run dev`，確認終端機顯示的訪問 URL 是 `https://` 開頭，並在瀏覽器中正常開啟。"
          }
        ]
      },
      {
        "id": 1,
        "title": "後端基礎建設：Node.js 與 Express HTTPS 伺服器設定",
        "description": "建立後端專案結構，使用 Node.js 和 Express.js 框架。此任務包含初始化專案、安裝必要套件以及設定基本的 HTTPS 伺服器，為後續的 API 和 WebSocket 功能打下基礎。",
        "details": "在 `server-ui-demo` 資料夾中初始化專案。安裝 Express.js、cors 等套件。建立主檔案 `server.js`，並設定一個基本的 Express 應用程式，使用 `https` 模組監聽指定埠號，並啟用 CORS 以允許前端存取。",
        "testStrategy": "啟動伺服器後，使用瀏覽器或 curl 工具訪問根路徑 (`https://localhost:PORT/`)，確認是否收到 '安心聊後端伺服器已啟動' 的回應。檢查伺服器日誌中是否有啟動成功的訊息。",
        "priority": "high",
        "dependencies": [
          0
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "初始化 Node.js 專案並設定基本結構",
            "description": "在指定資料夾中建立新的 Node.js 專案，初始化 package.json 檔案，並建立基本的專案目錄結構。",
            "dependencies": [],
            "details": "在 `server-ui-demo` 資料夾中執行 `npm init -y` 來初始化專案。建立基本的目錄結構，包括 `src/` 資料夾用於存放原始碼，`public/` 資料夾用於靜態檔案。確保 package.json 中包含正確的專案名稱、版本和描述資訊。",
            "status": "done",
            "testStrategy": "檢查 package.json 檔案是否正確生成，確認專案名稱和基本資訊是否正確設定。驗證目錄結構是否按預期建立。"
          },
          {
            "id": 2,
            "title": "安裝必要的 npm 套件",
            "description": "安裝 Express.js 框架和 CORS 中介軟體，以及其他後續開發所需的基礎套件。",
            "dependencies": [],
            "details": "執行 `npm install express cors` 安裝核心套件。同時安裝開發環境所需的套件：`npm install -D nodemon` 用於自動重啟伺服器。更新 package.json 中的 scripts 區段，新增 `\"start\": \"node server.js\"` 和 `\"dev\": \"nodemon server.js\"` 指令。",
            "status": "done",
            "testStrategy": "檢查 package.json 中的 dependencies 和 devDependencies 是否正確列出所安裝的套件。確認 node_modules 資料夾已建立且包含相關套件。"
          },
          {
            "id": 3,
            "title": "建立基本的 Express 伺服器檔案",
            "description": "建立主要的伺服器檔案 server.js，設定基本的 Express 應用程式結構和中介軟體。",
            "dependencies": [],
            "details": "建立 `server.js` 檔案，引入 express 和 cors 模組。設定 Express 應用程式實例，配置 CORS 中介軟體以允許跨域請求，使用 `express.json()` 中介軟體解析 JSON 請求體。定義環境變數 PORT，預設值為 8443。",
            "status": "done",
            "testStrategy": "檢查 server.js 檔案是否正確建立，確認所有必要的模組是否正確引入。驗證中介軟體設定是否完整。"
          },
          {
            "id": 4,
            "title": "實作根路徑路由和 HTTPS 伺服器啟動邏輯",
            "description": "建立根路徑的 GET 路由，並根據 Task 0 的設定，實作 HTTPS 伺服器啟動邏輯。",
            "dependencies": [
              0.3
            ],
            "details": "在 Express 應用程式中新增 `app.get('/', (req, res) => { res.send('安心聊後端伺服器已啟動'); });` 路由。使用 `https.createServer` 結合 SSL 憑證啟動伺服器，並確保伺服器實例被正確儲存，以便後續 WebSocket 整合使用。",
            "status": "done",
            "testStrategy": "使用 `npm run dev` 啟動伺服器，檢查控制台是否顯示啟動成功訊息。確認伺服器是否在指定埠號上以 HTTPS 正常運行。"
          }
        ]
      },
      {
        "id": 2,
        "title": "資料庫設定：SQLite 表格與索引建立",
        "description": "設定並初始化 SQLite 資料庫。根據 PRD 中的資料模型，建立 `users`、`call_history` 表格，並為 `call_history` 的 `caller_id` 和 `receiver_id` 建立索引以優化查詢效能。",
        "details": "安裝 SQLite 套件：`npm install sqlite3`。建立一個資料庫初始化腳本 `database.js`，用於連接資料庫檔案並執行 SQL `CREATE TABLE` 語句。PRD 提到 `online_users` 表格主要由記憶體管理，故此處僅建立 `users` 和 `call_history`。\n\n```sql\n-- database.js (SQL statements)\nCREATE TABLE IF NOT EXISTS users (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  name TEXT NOT NULL,\n  voip_id TEXT NOT NULL UNIQUE\n);\n\nCREATE TABLE IF NOT EXISTS call_history (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  caller_id INTEGER,\n  receiver_id INTEGER,\n  caller_ip TEXT,\n  receiver_ip TEXT,\n  start_time TEXT,\n  end_time TEXT,\n  duration_seconds INTEGER,\n  audio_url TEXT,\n  status TEXT,\n  FOREIGN KEY (caller_id) REFERENCES users (id),\n  FOREIGN KEY (receiver_id) REFERENCES users (id)\n);\n\nCREATE INDEX IF NOT EXISTS idx_caller_id ON call_history (caller_id);\nCREATE INDEX IF NOT EXISTS idx_receiver_id ON call_history (receiver_id);\n```",
        "testStrategy": "執行初始化腳本，並使用 SQLite CLI 或相關工具檢查資料庫檔案是否已成功建立，以及 `users` 和 `call_history` 表格的結構是否符合設計（包含 caller_ip 和 receiver_ip），索引是否已正確建立。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "安裝 SQLite3 套件並建立資料庫連接模組",
            "description": "為專案設定資料庫基礎。首先，使用 npm 安裝 `sqlite3` 套件。然後，建立一個新的 `database.js` 檔案，此檔案將負責建立或連接到指定的 SQLite 資料庫檔案（例如 `voip_demo.db`），並匯出一個可供其他模組使用的資料庫實例。",
            "dependencies": [],
            "details": "在終端機中執行 `npm install sqlite3`。建立 `src/database.js` 檔案。在此檔案中，引入 `sqlite3` 函式庫，定義資料庫檔案的路徑，並建立一個新的資料庫實例。處理基本的連接錯誤，並使用 `module.exports` 匯出該資料庫實例。",
            "status": "done",
            "testStrategy": "建立一個簡單的測試腳本，引入 `database.js` 並嘗試連接。執行後，檢查專案根目錄下是否已成功生成 `voip_demo.db` 檔案。"
          },
          {
            "id": 2,
            "title": "在初始化腳本中建立 `users` 表格",
            "description": "擴充 `database.js` 腳本，加入執行 SQL `CREATE TABLE` 語句的邏輯，以建立 `users` 表格。此表格將用於儲存使用者的基本資訊，包括唯一的 `voip_id`，是後續通話紀錄的基礎。",
            "dependencies": [
              2.1
            ],
            "details": "在 `database.js` 中，使用匯入的資料庫實例的 `db.run()` 或 `db.exec()` 方法。撰寫 `CREATE TABLE IF NOT EXISTS users (...)` 的 SQL 語句，包含 `id`, `name`, 和 `voip_id` 欄位，並確保 `voip_id` 是唯一的。將此執行邏輯包裝在一個初始化函式中。",
            "status": "done",
            "testStrategy": "執行初始化腳本。使用 SQLite CLI 或 GUI 工具（如 DB Browser for SQLite）打開 `voip_demo.db` 檔案，驗證 `users` 表格是否已建立，且其欄位（`id`, `name`, `voip_id`）與資料類型是否符合設計。"
          },
          {
            "id": 3,
            "title": "建立 `call_history` 表格並設定外鍵關聯",
            "description": "繼續擴充初始化腳本，新增建立 `call_history` 表格的 SQL 語句。此表格將記錄所有通話的詳細資訊，並透過外鍵（`caller_id`, `receiver_id`）與 `users` 表格建立關聯。",
            "dependencies": [
              2.2
            ],
            "details": "在 `database.js` 的初始化函式中，追加一個 `db.run()` 或 `db.exec()` 的呼叫。撰寫 `CREATE TABLE IF NOT EXISTS call_history (...)` 的 SQL 語句，包含所有必要欄位（特別是 `caller_ip` 和 `receiver_ip`），並使用 `FOREIGN KEY` 語法將 `caller_id` 和 `receiver_id` 指向 `users(id)`。建議在執行任何操作前先執行 `PRAGMA foreign_keys = ON;` 以啟用外鍵約束。",
            "status": "done",
            "testStrategy": "重新執行初始化腳本。使用資料庫工具檢查 `call_history` 表格是否已建立，並驗證其所有欄位及外鍵約束是否已正確設定。"
          },
          {
            "id": 4,
            "title": "為 `call_history` 表格的 `caller_id` 與 `receiver_id` 建立索引",
            "description": "為了優化未來根據通話發起者或接收者查詢通話紀錄的效能，在 `call_history` 表格的 `caller_id` 和 `receiver_id` 欄位上分別建立索引。",
            "dependencies": [
              2.3
            ],
            "details": "在 `database.js` 的初始化函式中，於建立 `call_history` 表格之後，再追加兩個 `db.run()` 呼叫。分別執行 `CREATE INDEX IF NOT EXISTS idx_caller_id ON call_history (caller_id);` 和 `CREATE INDEX IF NOT EXISTS idx_receiver_id ON call_history (receiver_id);`。",
            "status": "done",
            "testStrategy": "重新執行初始化腳本。使用 SQLite CLI，執行 `.indexes call_history` 或 `SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='call_history';` 命令，確認 `idx_caller_id` 和 `idx_receiver_id` 兩個索引已成功建立。"
          },
          {
            "id": 5,
            "title": "封裝資料庫初始化邏輯並整合至主應用程式",
            "description": "將所有資料庫表格與索引的建立邏輯重構並封裝成一個單一、可匯出的初始化函式。確保此函式能被主伺服器檔案（例如 `server.js`）引用並在應用程式啟動時自動執行，以保證資料庫結構隨時可用。",
            "dependencies": [
              2.4
            ],
            "details": "將 `database.js` 中的所有 `db.run()` 呼叫移入一個名為 `initializeDatabase` 的函式中。可使用 `db.serialize()` 來確保 SQL 命令按順序執行。從 `database.js` 中同時匯出 `db` 實例和 `initializeDatabase` 函式。在主應用程式入口檔案（`server.js`）的頂部，引入並呼叫 `initializeDatabase()`。",
            "status": "done",
            "testStrategy": "先手動刪除 `voip_demo.db` 檔案。然後，啟動主應用程式（例如 `node server.js`）。檢查 `voip_demo.db` 檔案是否被自動重新建立，並使用資料庫工具確認所有表格和索引都已按預期建立完成。"
          }
        ]
      },
      {
        "id": 3,
        "title": "即時通訊：WebSocket 信令與使用者狀態管理",
        "description": "使用 `ws` 套件建立 WebSocket 伺服器，用於處理 WebRTC 信令交換和即時使用者狀態同步。伺服器需要管理線上使用者列表，並在使用者連線或離線時廣播更新後的列表給所有客戶端。",
        "details": "安裝 `ws` 套件：`npm install ws`。將 WebSocket 伺服器附加到現有的 Express HTTPS 伺服器上。在記憶體中維護一個 Map 或 Object 來儲存線上使用者（key 為 `voip_id`，value 為 WebSocket 連線實例）。",
        "testStrategy": "使用簡單的 WebSocket 客戶端（如瀏覽器開發者工具或 `wscat` 工具）進行連線測試。驗證連線成功後，伺服器能正確接收訊息並廣播使用者列表。模擬多個客戶端連線與離線，檢查列表是否即時更新。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "建立並附加 WebSocket 伺服器實例",
            "description": "初始化 `ws` 套件，建立一個 WebSocketServer 實例，並將其附加到 Task 1 中建立的現有 Express HTTPS 伺服器上。實現基本的 `connection` 事件監聽，以驗證伺服器設定正確且客戶端可以成功建立連線。",
            "dependencies": [],
            "details": "在 `server.js` 中，引入 `ws` 的 `WebSocketServer`。使用從 `https.createServer()` 返回的 `server` 物件來實例化 `wss`。在 `wss.on('connection', ...)` 回呼函式中，加入 `console.log('客戶端已連線');` 來確認連線成功。",
            "status": "done",
            "testStrategy": "啟動後端伺服器。使用任何 WebSocket 客戶端工具（如瀏覽器的開發者工具 Console 或 `wscat`）嘗試連線到 `wss://localhost:PORT`。檢查伺服器終端機是否成功輸出「客戶端已連線」的日誌訊息。"
          },
          {
            "id": 2,
            "title": "處理使用者註冊與加入線上列表",
            "description": "實作 `message` 事件監聽器，以處理使用者連線後發送的註冊訊息。當收到類型為 'login' 的訊息時，將使用者的 `voip_id` 與其 WebSocket 連線實例（`ws`）關聯並存入 `onlineUsers` Map 中，以便後續識別與通訊。",
            "dependencies": [
              3.1
            ],
            "details": "在 `wss.on('connection', ...)` 內，為每個 `ws` 連線新增 `ws.on('message', ...)` 監聽器。解析收到的 JSON 訊息。如果 `data.type === 'login'`，則將 `voip_id` 附加到 `ws` 物件上（例如 `ws.voip_id = data.voip_id;`），然後將鍵值對 `[data.voip_id, ws]` 存入 `onlineUsers` Map。",
            "status": "done",
            "testStrategy": "連線一個客戶端並發送 JSON 訊息 `{\"type\": \"login\", \"voip_id\": \"user-A\"}`。在伺服器端，於處理 'login' 訊息後打印 `onlineUsers` Map 的內容，驗證 `user-A` 是否已成功加入。"
          },
          {
            "id": 3,
            "title": "廣播更新後的線上使用者列表",
            "description": "建立一個輔助函式 `broadcastUserList`，用於向所有已連線的客戶端廣播當前的線上使用者列表。每當有新使用者成功註冊後，應立即呼叫此函式，確保所有客戶端的使用者列表保持同步。",
            "dependencies": [
              3.2
            ],
            "details": "建立函式 `broadcastUserList()`。在函式內部，使用 `Array.from(onlineUsers.keys())` 獲取所有線上使用者的 `voip_id` 陣列。將此陣列包裝成一個 JSON 物件，例如 `{\"type\": \"user-list\", \"users\": [...]}`。然後遍歷 `wss.clients`，將此 JSON 字串發送給每一個處於 `OPEN` 狀態的客戶端。在處理 'login' 訊息並將使用者加入 Map 後呼叫此函式。",
            "status": "done",
            "testStrategy": "依序連線兩個客戶端（A 和 B）並各自完成登入。驗證當 B 登入後，A 和 B 都會收到一個 `user-list` 訊息，且該訊息的 `users` 陣列應包含 `['user-A', 'user-B']`。"
          },
          {
            "id": 4,
            "title": "處理使用者離線與列表更新廣播",
            "description": "為每個 WebSocket 連線實作 `close` 事件的處理邏輯。當客戶端連線中斷時，伺服器需要從 `onlineUsers` Map 中移除該使用者，並再次呼叫 `broadcastUserList` 函式，以通知所有剩餘的客戶端該使用者已離線。",
            "dependencies": [
              3.3
            ],
            "details": "在 `wss.on('connection', ...)` 內，為每個 `ws` 連線新增 `ws.on('close', ...)` 監聽器。在回呼函式中，使用先前儲存在 `ws.voip_id` 的值從 `onlineUsers` Map 中刪除對應的條目。刪除成功後，立即呼叫 `broadcastUserList()`。",
            "status": "done",
            "testStrategy": "連線客戶端 A 和 B，確認雙方都收到包含兩人的列表。然後關閉客戶端 A 的連線。驗證客戶端 B 是否立即收到一個新的 `user-list` 訊息，且其 `users` 陣列只包含 `['user-B']`。"
          },
          {
            "id": 5,
            "title": "實作 WebRTC 信令轉發邏輯",
            "description": "擴充 `message` 事件處理器，使其能夠識別並轉發 WebRTC 信令（如 'offer', 'answer', 'candidate'）。伺服器作為信令中繼，根據訊息中的 `target_voip_id` 欄位，將信令準確地傳送給指定的目標使用者。",
            "dependencies": [
              3.2
            ],
            "details": "在 `ws.on('message', ...)` 的邏輯中，增加 `else if` 條件來檢查 `data.type` 是否為 'offer', 'answer' 或 'candidate'。如果是，則從 `data.target_voip_id` 獲取目標使用者 ID，並使用 `onlineUsers.get()` 查找對應的 `ws` 連線。如果找到目標連線，為了讓接收方知道是誰發來的，可以在轉發的訊息中加入 `sender_voip_id`（值為 `ws.voip_id`），然後將完整的訊息發送給目標使用者。",
            "status": "done",
            "testStrategy": "連線客戶端 A 和 B 並登入。讓客戶端 A 發送一條信令訊息，例如 `{\"type\": \"offer\", \"target_voip_id\": \"user-B\", \"sdp\": \"...\"}`。驗證只有客戶端 B 收到了這條訊息，且訊息內容被正確轉發。同時確認客戶端 A 或其他無關客戶端沒有收到此訊息。"
          },
          {
            "id": 6,
            "title": "處理手動刷新列表請求",
            "description": "擴充 `message` 事件處理器，使其能回應前端發送的「同步資料」請求，單獨向該客戶端回傳最新的使用者列表。",
            "dependencies": [
              3.2
            ],
            "details": "在 `ws.on('message', ...)` 的邏輯中，增加一個 `else if` 條件來檢查 `data.type === 'request-user-list'`。如果條件成立，則獲取當前的線上使用者列表，並將其包裝成 `user-list` 訊息，但這次只發送給發起請求的那個 `ws` 客戶端，而不是廣播給所有人。",
            "status": "done",
            "testStrategy": "連線客戶端 A 和 B。在客戶端 A 上發送 `{\"type\": \"request-user-list\"}` 訊息。驗證只有客戶端 A 收到了包含 A 和 B 的使用者列表，而客戶端 B 沒有收到任何訊息。"
          }
        ]
      },
      {
        "id": 4,
        "title": "前端基礎建設：Vite + React + TypeScript 專案設定",
        "description": "開發前端專案的基礎結構，使用 Vite、React 和 TypeScript。並整合 Tailwind CSS 進行樣式設計，建立符合 `mobile-ui.png` 視覺稿的初始介面佈局。",
        "details": "在 `voip-demo` 資料夾中執行 `npm create vite@latest . -- --template react-ts`。接著，按照 Tailwind CSS 官方文件指引進行安裝與設定。建立主要的 React 元件，並使用 Tailwind CSS class 來建構使用者名稱輸入、連線按鈕、聯絡人下拉選單等 UI 元素。根據 Task 0 的要求，設定 Vite 為 HTTPS 模式。",
        "testStrategy": "執行 `npm run dev` 啟動開發伺服器。在瀏覽器中打開 `https://` 開頭的頁面，確認 Vite + React 應用程式能正常運行。檢查 UI 元素是否已根據 `mobile-ui.png` 的佈局初步呈現，且 Tailwind CSS 樣式已正確應用。",
        "priority": "high",
        "dependencies": [
          0,
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "初始化 Vite + React + TypeScript 專案",
            "description": "使用 Vite CLI 建立一個包含 React 和 TypeScript 的基礎專案結構。這是所有前端開發工作的起點。",
            "dependencies": [],
            "details": "在專案根目錄 `voip-demo` 中，執行指令 `npm create vite@latest . -- --template react-ts`。完成後，執行 `npm install` 安裝所有基礎依賴。",
            "status": "done",
            "testStrategy": "執行 `npm run dev` 啟動開發伺服器。在瀏覽器中打開終端機顯示的 URL，確認預設的 Vite + React 頁面能夠正常顯示。"
          },
          {
            "id": 2,
            "title": "整合與設定 Tailwind CSS",
            "description": "將 Tailwind CSS 新增至專案中，並進行必要的設定，以便在 React 元件中使用其 utility classes 進行樣式設計。",
            "dependencies": [
              4.1
            ],
            "details": "1. 執行 `npm install -D tailwindcss postcss autoprefixer` 安裝開發依賴。\n2. 執行 `npx tailwindcss init -p` 產生 `tailwind.config.js` 和 `postcss.config.js`。\n3. 在 `tailwind.config.js` 的 `content` 屬性中設定掃描路徑：`['./index.html', './src/**/*.{js,ts,jsx,tsx}']`。\n4. 在 `src/index.css` 檔案中加入 Tailwind 的三個核心指令：`@tailwind base; @tailwind components; @tailwind utilities;`。\n5. 確認 `main.tsx` 中已匯入 `index.css`。",
            "status": "done",
            "testStrategy": "在 `App.tsx` 中，為任一 HTML 元素（例如 `<h1>`）添加一個 Tailwind class，如 `className=\"text-3xl font-bold underline text-red-500\"`。重新啟動開發伺服器，確認該元素的樣式已成功應用。"
          },
          {
            "id": 3,
            "title": "建立核心元件檔案結構",
            "description": "清理 Vite 樣板程式碼，並建立專案所需的核心元件檔案（如 App.tsx, CallView.tsx），為後續的 UI 開發奠定良好的組織基礎。",
            "dependencies": [
              4.2
            ],
            "details": "1. 刪除 `src/assets` 中的預設圖檔和 `App.css`。\n2. 清空 `App.tsx` 的內容，將其作為應用的根容器。\n3. 在 `src` 目錄下建立 `views` 或 `pages` 資料夾，並在其中建立 `CallView.tsx` 檔案。\n4. 在 `CallView.tsx` 中建立一個基本的 React 元件 boilerplate。\n5. 在 `App.tsx` 中匯入並渲染 `CallView` 元件，使其成為頁面的主要內容。",
            "status": "done",
            "testStrategy": "在 `CallView.tsx` 中加入一個簡單的標題，例如 `<h1>VoIP 通話介面</h1>`。執行 `npm run dev`，確認頁面上只顯示這個標題，表示元件結構重構成功。"
          },
          {
            "id": 4,
            "title": "實作符合 mobile-ui.png 的主體佈局",
            "description": "根據 `mobile-ui.png` 視覺稿，使用 Tailwind CSS 在 `CallView.tsx` 中建立應用的主要視覺佈局，包括容器、背景和區塊劃分。",
            "dependencies": [
              4.3
            ],
            "details": "在 `CallView.tsx` 中，使用 Tailwind CSS 的 flexbox 或 grid 系統來建構頁面。建立一個全螢幕的根 `<div>` 並設定背景色。在其內部建立一個居中的卡片式容器，用來放置所有互動元素。此階段專注於宏觀佈局、間距和區塊劃分，暫不實作具體元件。",
            "status": "done",
            "testStrategy": "在瀏覽器中檢視頁面，並與 `mobile-ui.png` 進行比對。確認頁面的整體結構、背景顏色、容器尺寸與位置都與設計稿相符。可以使用瀏覽器開發者工具來檢查元素的尺寸和間距。"
          },
          {
            "id": 5,
            "title": "建構使用者互動 UI 元素",
            "description": "在已建立的佈局中，實作 `mobile-ui.png` 中定義的具體 UI 元素，包括使用者名稱輸入框、連線按鈕和聯絡人下拉選單。",
            "dependencies": [
              4.4
            ],
            "details": "1. 在 `CallView.tsx` 的對應區塊中，新增 `<input type='text'>` 用於輸入使用者名稱，並使用 Tailwind class 設定其樣式（邊框、內距、佔位符文字樣式）。\n2. 新增 `<button>` 用於連線，並設定其背景色、文字顏色、圓角和 hover 效果。\n3. 新增 `<select>` 元素作為聯絡人下拉選單，並為其添加基本的樣式。目前只需包含靜態的 `<option>` 即可。",
            "status": "done",
            "testStrategy": "再次將瀏覽器畫面與 `mobile-ui.png` 進行精細比對。確認輸入框、按鈕、下拉選單的視覺細節（顏色、字體大小、圓角、陰影等）都與設計稿一致。將滑鼠懸停在按鈕上，檢查 hover 效果是否正確。"
          }
        ]
      },
      {
        "id": 5,
        "title": "前端連線：WebSocket 客戶端與線上列表同步",
        "description": "在前端 React 應用中實現 WebSocket 客戶端邏輯。使用者輸入名稱並點擊「連線」後，與後端建立 WebSocket 連線，並接收伺服器推送的線上使用者列表，動態更新「選擇聯絡人」下拉選單。",
        "details": "在主元件中使用 `useEffect` hook 來建立和管理 WebSocket 連線。使用 `useState` 來儲存線上使用者列表。當 WebSocket 收到訊息時，解析 JSON 並更新狀態，觸發 UI 重新渲染。",
        "testStrategy": "在瀏覽器中運行前端應用。輸入名稱並點擊連線，檢查瀏覽器開發者工具的 Network 分頁，確認 WebSocket 連線是否成功建立 (狀態碼 101)。驗證「選擇聯絡人」下拉選單是否能正確顯示由伺服器推送的其他線上使用者。",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "建立狀態管理與 UI 控制邏輯",
            "description": "在 React 主元件 (`App.tsx`) 中，使用 `useState` hooks 來定義和管理使用者介面所需的各種狀態，包括使用者輸入的名稱、WebSocket 的連線狀態、WebSocket 連線實例以及從伺服器獲取的線上使用者列表。",
            "dependencies": [],
            "details": "在 `App.tsx` 元件中宣告以下狀態：\n`const [username, setUsername] = useState('');`\n`const [connectionStatus, setConnectionStatus] = useState('disconnected');` // 可能的狀態: 'disconnected', 'connecting', 'connected'\n`const [onlineUsers, setOnlineUsers] = useState([]);`\n`const [socket, setSocket] = useState<WebSocket | null>(null);`\n將使用者名稱輸入框的 `value` 與 `onChange` 事件分別綁定到 `username` 狀態及其更新函式。",
            "status": "done",
            "testStrategy": "在瀏覽器中運行應用，確認使用者名稱輸入框可以正常輸入文字，且其值與 React DevTools 中顯示的 `username` 狀態同步。驗證頁面初始載入時，連線狀態的 UI 顯示為「已斷線」。"
          },
          {
            "id": 2,
            "title": "實現 WebSocket 連線觸發函式",
            "description": "建立一個處理連線邏輯的函式，當使用者點擊「連線」按鈕時被呼叫。此函式負責驗證輸入、更新 UI 狀態為「連線中」，並初始化與後端伺服器的 WebSocket 連線。",
            "dependencies": [
              5.1
            ],
            "details": "建立一個名為 `handleConnect` 的非同步函式。在此函式中，首先檢查 `username` 是否為空，若為空則提示使用者。接著，呼叫 `setConnectionStatus('connecting')` 來更新 UI。然後，建立一個新的 WebSocket 實例：`const ws = new WebSocket('wss://your-backend-url');`（URL 應從環境變數或設定檔讀取）。最後，將此 `ws` 實例存入狀態：`setSocket(ws);`。將此函式綁定到「連線」按鈕的 `onClick` 事件。",
            "status": "done",
            "testStrategy": "點擊「連線」按鈕後，UI 應顯示「連線中...」的視覺回饋。打開瀏覽器開發者工具的「Network」分頁，確認一個對 WebSocket 端點的請求已被發起，且其狀態為 `101 Switching Protocols`。"
          },
          {
            "id": 3,
            "title": "處理 WebSocket 連線生命週期事件 (onopen, onclose)",
            "description": "在 WebSocket 實例上綁定 `onopen` 和 `onclose` 事件的處理器。`onopen` 事件在連線成功建立時觸發，用於向伺服器發送使用者身份訊息。`onclose` 事件在連線關閉時觸發，用於清理狀態並更新 UI。",
            "dependencies": [
              5.2
            ],
            "details": "在 `handleConnect` 函式中，緊接著建立 `ws` 實例後，為其設定事件處理器。\n`ws.onopen = () => {`\n  `console.log('WebSocket connected');`\n  `ws.send(JSON.stringify({ type: 'login', name: username }));`\n  `setConnectionStatus('connected');`\n`};`\n`ws.onclose = () => {`\n  `console.log('WebSocket disconnected');`\n  `setConnectionStatus('disconnected');`\n  `setOnlineUsers([]);`\n  `setSocket(null);`\n`};`",
            "status": "done",
            "testStrategy": "連線成功後，檢查 Network 分頁中 WebSocket 的訊息框架，確認一條包含 `{ \"type\": \"login\", ... }` 的訊息已發送至伺服器。同時，UI 應更新為「已連線」狀態。若手動停止後端伺服器，應能觀察到前端 UI 自動切換回「已斷線」狀態，且聯絡人列表被清空。"
          },
          {
            "id": 4,
            "title": "處理伺服器訊息並更新線上使用者列表",
            "description": "為 WebSocket 實例綁定 `onmessage` 事件處理器，以接收並處理來自伺服器的所有訊息。特別是，當收到類型為 `user-list` 的訊息時，需解析其內容並更新線上使用者列表的狀態。",
            "dependencies": [
              5.3
            ],
            "details": "在 `handleConnect` 函式中，為 `ws` 實例設定 `onmessage` 處理器。\n`ws.onmessage = (event) => {`\n  `const data = JSON.parse(event.data);`\n  `if (data.type === 'user-list') {`\n    `// 過濾掉自己，避免在聯絡人列表中看到自己`\n    `const filteredUsers = data.users.filter(user => user.name !== username);`\n    `setOnlineUsers(filteredUsers);`\n  `}`\n  `// ... 處理其他類型的信令訊息`\n`};`",
            "status": "done",
            "testStrategy": "開啟兩個不同的瀏覽器視窗，並使用不同的使用者名稱連線到應用。驗證在每個視窗的「選擇聯絡人」下拉選單中，都能看到另一個使用者的名稱。當其中一個視窗關閉或斷線時，驗證另一個視窗的聯絡人列表會即時更新，移除該離線使用者。"
          },
          {
            "id": 5,
            "title": "動態渲染下拉選單並根據連線狀態更新 UI",
            "description": "將 `onlineUsers` 狀態與「選擇聯絡人」的 `<select>` 元件進行綁定，使其能夠動態地根據狀態變化來渲染選項。同時，根據 `connectionStatus` 狀態來啟用或禁用相關的 UI 元件，以提供更好的使用者體驗。",
            "dependencies": [
              5.1,
              5.4
            ],
            "details": "在 `App.tsx` 的 JSX 中，使用 `onlineUsers.map()` 方法來迭代 `onlineUsers` 陣列，為每個使用者渲染一個 `<option>` 元素。例如：\n`<select>`\n  `{onlineUsers.map(user => <option key={user.voip_id} value={user.voip_id}>{user.name}</option>)}`\n`</select>`\n使用條件判斷來控制 UI 元素的 `disabled` 屬性，例如：\n`<input ... disabled={connectionStatus !== 'disconnected'} />`\n`<button ... disabled={connectionStatus !== 'disconnected'}>連線</button>`",
            "status": "done",
            "testStrategy": "驗證當有新使用者連線或離線時，下拉選單的內容會即時、正確地更新。確認一旦連線成功，使用者名稱輸入框和「連線」按鈕會變為不可用狀態，防止使用者重複操作。"
          },
          {
            "id": 6,
            "title": "實作「同步資料」手動刷新功能",
            "description": "為「同步資料」按鈕添加功能，允許使用者手動觸發向伺服器請求最新的線上使用者列表。",
            "dependencies": [
              5.2
            ],
            "details": "在 UI 中建立一個「同步資料」按鈕。為其 `onClick` 事件綁定一個處理函式。該函式會檢查 WebSocket 連線是否存在且處於開啟狀態，如果是，則發送一條訊息：`socket.send(JSON.stringify({ type: 'request-user-list' }))`。",
            "status": "done",
            "testStrategy": "連線後，手動在後端新增一個使用者（或透過另一個客戶端連線），但前端 UI 不會自動更新。點擊「同步資料」按鈕，驗證前端的聯絡人列表是否被成功刷新。"
          }
        ]
      },
      {
        "id": 6,
        "title": "核心通話功能：WebRTC 點對點語音串流實現",
        "description": "整合 WebRTC `RTCPeerConnection` API，實現瀏覽器之間的點對點語音串流。這包括建立連線、透過 WebSocket 信令伺服器交換 SDP (Offer/Answer) 和 ICE 候選者，以及處理通話狀態（撥號、來電、接聽、掛斷）。",
        "details": "建立一個 WebRTC 管理服務或 hook (`useWebRTC`)。配置 `RTCPeerConnection` 並指定 STUN 伺服器：`{ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }`。實作 `createOffer`、`createAnswer` 流程，並將產生的 SDP 和 ICE 候選者透過 WebSocket 傳送給對方。監聽 `ontrack` 事件以接收遠端音訊流，並將其附加到 `<audio>` 元素上播放。",
        "testStrategy": "使用兩個瀏覽器分頁模擬兩位使用者。使用者 A 向使用者 B 發起通話。檢查 WebSocket 訊息，確認 'offer', 'answer', 'candidate' 信令是否正確交換。驗證通話接通後，雙方是否能聽到對方的聲音，且音訊是透過 P2P 傳輸（可使用 `chrome://webrtc-internals` 進行驗證）。",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "建立 `useWebRTC` Hook 與 `RTCPeerConnection` 初始化",
            "description": "建立一個名為 `useWebRTC` 的 React Custom Hook，用於封裝所有 WebRTC 相關的邏輯。此 Hook 將負責初始化及管理 `RTCPeerConnection` 實例，並設定 STUN 伺服器以進行 NAT 穿透。",
            "dependencies": [],
            "details": "在 `src/hooks` 目錄下建立 `useWebRTC.ts` 檔案。在 Hook 內部，使用 `useRef` 來存放 `RTCPeerConnection` 實例，以避免在每次渲染時重新建立。初始化時，傳入 STUN 伺服器設定：`{ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }`。同時，使用 `useState` 管理本地音訊流 (`localStream`) 和遠端音訊流 (`remoteStream`) 的狀態。",
            "status": "done",
            "testStrategy": "在主應用程式元件中調用 `useWebRTC` Hook。檢查瀏覽器開發者工具，確認在元件掛載後，`RTCPeerConnection` 物件被成功建立（雖然此時還沒有連線）。"
          },
          {
            "id": 2,
            "title": "實現撥號方邏輯：取得麥克風權限與建立 Offer",
            "description": "在 `useWebRTC` Hook 中實作一個 `startCall` 函式。當使用者發起通話時，此函式會請求麥克風權限，將本地音訊軌道加入 `RTCPeerConnection`，然後建立一個 SDP Offer 並透過 WebSocket 信令伺服器傳送給對方。",
            "dependencies": [
              6.1
            ],
            "details": "在 `useWebRTC` 中新增 `startCall(targetVoipId)` 函式。使用 `navigator.mediaDevices.getUserMedia({ audio: true })` 取得本地音訊流，並將其存入 `localStream` 狀態。使用 `localStream.getTracks().forEach(track => peerConnection.current.addTrack(track, localStream))` 將音軌加入連線。接著，呼叫 `peerConnection.current.createOffer()`，然後用 `peerConnection.current.setLocalDescription(offer)` 設定本地描述。最後，將包含 `targetVoipId` 和 `offer` 的信令物件透過 WebSocket 傳送出去。",
            "status": "done",
            "testStrategy": "在 UI 中加入一個「撥號」按鈕。點擊後，檢查瀏覽器是否彈出麥克風授權請求。授權後，檢查 WebSocket 傳出的訊息，確認是否包含一個類型為 'offer' 且格式正確的 SDP 訊息。"
          },
          {
            "id": 3,
            "title": "實現接聽方邏輯：處理 Offer 並建立 Answer",
            "description": "擴充 `useWebRTC` Hook 以處理接收到的 Offer。當 WebSocket 收到 'offer' 信令時，接聽方需要設定遠端描述、取得自己的麥克風音訊、建立一個 Answer，並將其回傳給撥號方。",
            "dependencies": [
              6.1
            ],
            "details": "在 `useWebRTC` 中新增一個 `handleReceiveOffer(offer, callerVoipId)` 函式。此函式首先呼叫 `peerConnection.current.setRemoteDescription(new RTCSessionDescription(offer))`。接著，像 `startCall` 一樣，取得本地麥克風音訊流並加入軌道。然後，呼叫 `peerConnection.current.createAnswer()`，用 `peerConnection.current.setLocalDescription(answer)` 設定本地描述，最後將包含 `callerVoipId` 和 `answer` 的信令物件透過 WebSocket 回傳。",
            "status": "done",
            "testStrategy": "使用兩個瀏覽器分頁。在分頁 A 撥號給分頁 B。在分頁 B，檢查 WebSocket 是否收到 'offer' 訊息。驗證 `handleReceiveOffer` 函式被觸發後，分頁 B 是否也發送了一個類型為 'answer' 的 WebSocket 訊息回給分頁 A。"
          },
          {
            "id": 4,
            "title": "處理 ICE 候選者交換與遠端音訊流",
            "description": "完成 SDP 交換後，雙方需要交換 ICE 候選者來建立直接連線。同時，需要監聽 `ontrack` 事件以接收遠端的音訊流。",
            "dependencies": [
              6.2,
              6.3
            ],
            "details": "在 `useWebRTC` Hook 的初始化邏輯中，設定 `peerConnection.current.onicecandidate` 事件監聽器。當事件觸發時，如果 `event.candidate` 存在，就將其透過 WebSocket 傳送給對方。同時，建立一個處理 'candidate' 類型 WebSocket 訊息的邏輯，當收到對方傳來的候選者時，呼叫 `peerConnection.current.addIceCandidate(new RTCIceCandidate(candidate))`。最後，設定 `peerConnection.current.ontrack` 監聽器，當接收到遠端軌道時，將 `event.streams[0]` 存入 `remoteStream` 狀態。",
            "status": "done",
            "testStrategy": "在通話過程中，監控 WebSocket 訊息，確認雙方都在交換類型為 'candidate' 的訊息。使用 `chrome://webrtc-internals` 工具檢查 ICE 連線狀態是否變為 'connected' 或 'completed'。確認 `ontrack` 事件被觸發且 `remoteStream` 狀態被成功設定。"
          },
          {
            "id": 5,
            "title": "實現通話掛斷與遠端音訊播放",
            "description": "提供掛斷通話的功能，並將接收到的遠端音訊流附加到一個 `<audio>` 元素上進行播放，完成整個通話流程的閉環。",
            "dependencies": [
              6.4
            ],
            "details": "在 `useWebRTC` Hook 中新增一個 `hangUp` 函式。此函式需要關閉 `RTCPeerConnection` (`peerConnection.current.close()`)，停止本地媒體軌道 (`localStream?.getTracks().forEach(track => track.stop())`)，並透過 WebSocket 發送 'hang-up' 信令通知對方。在 React 元件中，使用 `useEffect` 監聽 `remoteStream` 狀態的變化。當 `remoteStream` 有值時，將其設定為一個 `<audio>` 元素的 `srcObject` 屬性，並設定 `autoPlay`。這個 `<audio>` 元素可以隱藏在頁面中。",
            "status": "done",
            "testStrategy": "通話建立後，確認能聽到對方的聲音。點擊「掛斷」按鈕，檢查 `hangUp` 函式是否被呼叫，WebSocket 是否發送了 'hang-up' 訊息，並且雙方的 `RTCPeerConnection` 狀態是否變為 'closed'。確認音訊串流停止。"
          }
        ]
      },
      {
        "id": 7,
        "title": "前端語音錄製：使用 MediaRecorder API",
        "description": "在前端實現通話過程中的語音錄製功能。利用瀏覽器原生的 `MediaRecorder` Web API 捕獲本地和遠端的音訊流，並在通話結束時將其合併或處理成單一的音訊檔案。",
        "details": "當 WebRTC 連線狀態變為 'connected' 時，從 `RTCPeerConnection` 獲取本地和遠端的 `MediaStreamTrack`，將它們合併到一個新的 `MediaStream` 中。使用此 `MediaStream` 實例化 `MediaRecorder`。",
        "testStrategy": "在一次成功的通話中，檢查瀏覽器記憶體使用情況，確認 `MediaRecorder` 正在緩存音訊數據。通話結束後，在 `onstop` 事件中設置斷點，檢查 `audioBlob` 是否成功生成且大小不為零。可以手動將此 Blob 轉換為 URL 並在瀏覽器中播放，以驗證錄音內容是否正確。",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "整合錄音狀態管理至 React Hook",
            "description": "在現有的 `useWebRTC` hook 或相關的狀態管理模組中，加入用於控制和追蹤錄音過程的狀態變數。這包括錄音器實例、音訊數據塊陣列以及錄音狀態旗標，為後續的錄音邏輯提供基礎。",
            "dependencies": [],
            "details": "在 `useWebRTC.ts` 中，使用 `useRef` 來創建 `mediaRecorderRef` 以保存 `MediaRecorder` 實例，以及 `audioChunksRef` 來存儲錄音數據塊（Blob），避免不必要的組件重渲染。可以選擇性地加入一個 `useState` 來管理錄音狀態，例如 `const [isRecording, setIsRecording] = useState(false);`。",
            "status": "done",
            "testStrategy": "在 React DevTools 中檢查 `useWebRTC` hook 的狀態，確認在元件掛載後，`mediaRecorderRef` 和 `audioChunksRef` 已被正確初始化為其預設值（例如 `null` 和 `[]`）。"
          },
          {
            "id": 2,
            "title": "獲取並合併本地與遠端音訊流",
            "description": "實作一個函式，當 WebRTC 連線成功建立後，從 `RTCPeerConnection` 物件中提取本地（`getSenders`）和遠端（`getReceivers`）的音訊軌道 (`MediaStreamTrack`)，並將它們合併成一個新的 `MediaStream` 物件，以供 `MediaRecorder` 使用。",
            "dependencies": [
              7.1
            ],
            "details": "創建一個名為 `createCombinedStream` 的輔助函式，接收 `peerConnection` 作為參數。函式內部，遍歷 `peerConnection.getSenders()` 和 `peerConnection.getReceivers()`，篩選出 `track.kind === 'audio'` 的音訊軌道。使用 `new MediaStream()` 構造函數，並將收集到的所有音訊軌道作為參數傳入，最後返回這個合併後的 `MediaStream`。",
            "status": "done",
            "testStrategy": "在通話連接後，手動調用此函式，並在瀏覽器控制台中打印返回的 `MediaStream` 物件。檢查其 `getAudioTracks()` 方法返回的陣列長度是否為 2（假設為雙方通話），確認本地和遠端音軌都已包含在內。"
          },
          {
            "id": 3,
            "title": "初始化並啟動 MediaRecorder",
            "description": "基於合併後的音訊流來實例化 `MediaRecorder`。設定 `ondataavailable` 事件監聽器以收集錄製的音訊數據，並在通話成功連接時正式啟動錄音。",
            "dependencies": [
              7.2
            ],
            "details": "創建一個 `startRecording` 函式。此函式首先調用 `createCombinedStream` 獲取合併流。然後，使用 `new MediaRecorder(combinedStream, { mimeType: 'audio/webm;codecs=opus' })` 進行實例化，並將其賦值給 `mediaRecorderRef.current`。設定 `mediaRecorderRef.current.ondataavailable` 事件處理器，將 `event.data` 推入 `audioChunksRef.current` 陣列中。最後，調用 `mediaRecorderRef.current.start()`。",
            "status": "done",
            "testStrategy": "在通話連接後觸發 `startRecording`。在開發者工具的 Performance Monitor 中觀察 JavaScript 記憶體使用情況，應能看到記憶體隨著錄音時間的推移而穩定增長，表明 `audioChunks` 正在被填充。"
          },
          {
            "id": 4,
            "title": "實現錄音停止與音訊 Blob 生成",
            "description": "實作停止錄音的邏輯。當通話結束時，安全地停止 `MediaRecorder`，並在其 `onstop` 事件中將所有收集到的音訊數據塊合併成一個單一的、可用的 `Blob` 物件。",
            "dependencies": [
              7.3
            ],
            "details": "創建一個 `stopRecording` 函式。此函式檢查 `mediaRecorderRef.current` 的狀態是否為 'recording'，如果是，則調用 `stop()` 方法。在 `startRecording` 函式中初始化 `MediaRecorder` 時，同時定義 `onstop` 事件處理器。在 `onstop` 處理器中，使用 `new Blob(audioChunksRef.current, { type: 'audio/webm' })` 來創建最終的音訊 Blob。創建 Blob 後，應將 `audioChunksRef.current` 清空，為下一次錄音做準備。",
            "status": "done",
            "testStrategy": "在通話中錄音一段時間後，手動調用 `stopRecording`。在 `onstop` 處理器中設置斷點，檢查 `audioBlob` 物件是否成功生成，其 `size` 屬性是否大於 0，以及 `type` 屬性是否正確。可以將此 Blob 轉換為 URL (`URL.createObjectURL`) 並在新的瀏覽器分頁中播放，以驗證錄音內容。"
          },
          {
            "id": 5,
            "title": "將錄音生命週期與通話狀態掛鉤",
            "description": "將 `startRecording` 和 `stopRecording` 函式與 WebRTC 的通話生命週期事件進行整合，實現錄音的自動化。監聽 `RTCPeerConnection` 的連線狀態，在連線成功時開始錄音，在掛斷通話時停止錄音。",
            "dependencies": [
              7.4
            ],
            "details": "在 `useWebRTC` hook 中，使用 `useEffect` 或在適當的回調中監聽 `peerConnection.connectionState` 的變化。當狀態變為 `'connected'` 時，調用 `startRecording()`。修改處理掛斷邏輯的函式（例如 `hangUpCall`），在清理 `peerConnection` 之前，先調用 `stopRecording()`。在 `onstop` 事件中生成的 `audioBlob` 應被傳遞給一個回調函式或更新到一個狀態中，以便後續的上傳任務（Task 9）可以使用它。",
            "status": "done",
            "testStrategy": "進行一次完整的端對端通話測試。A 使用者呼叫 B 使用者，B 接聽。驗證通話接通後錄音自動開始。通話幾秒後，任一方掛斷。驗證錄音自動停止，並且在 `onstop` 事件中成功生成了音訊 Blob。檢查控制台日誌，確認整個流程符合預期，沒有錯誤拋出。"
          }
        ]
      },
      {
        "id": 8,
        "title": "後端檔案處理：錄音檔上傳、下載與歷史紀錄 API",
        "description": "在後端 Express 伺服器上建立 RESTful API 端點，用於接收前端上傳的錄音檔案、提供下載功能，以及查詢通話歷史紀錄。",
        "details": "安裝 `multer` 來處理檔案上傳。設定 `POST /api/upload` 路由，根據通話 ID 實現「先到先得」的儲存策略。建立 `GET /api/download/:callId` 路由提供檔案下載。建立 `GET /api/history` 路由，用於查詢並回傳所有通話紀錄。",
        "testStrategy": "使用 Postman 測試 `/api/upload`、`/api/download/:callId` 和 `/api/history` 三個端點，確認檔案能正確上傳、下載，且歷史紀錄列表能被正確查詢和回傳。",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "設定 Multer 中介軟體與檔案儲存策略",
            "description": "安裝 `multer` 套件並在 Express 應用程式中進行基礎設定。這包括定義檔案儲存的位置（例如 `uploads/` 目錄）以及檔案命名規則，以確保檔案名唯一且與通話 ID 相關聯。",
            "dependencies": [],
            "details": "執行 `npm install multer`。在伺服器專案中建立一個設定檔或在中介軟體層，配置 `multer.diskStorage`。設定 `destination` 為一個固定的伺服器目錄，例如 `'./uploads'`。在 `filename` 函式中，從請求主體 `req.body` 讀取 `callId`，並將檔案名稱設定為 `[callId].wav` 或其他合適的格式，以確保檔案名稱的唯一性並易於查找。",
            "status": "done",
            "testStrategy": "手動建立一個簡單的測試路由，該路由僅使用設定好的 multer 中介軟體。透過 Postman 發送一個帶有檔案和 `callId` 的請求，檢查 `uploads` 目錄中是否成功生成了以 `callId` 命名的檔案。"
          },
          {
            "id": 2,
            "title": "實作檔案上傳路由 (POST /api/upload) 與「首次上傳」邏輯",
            "description": "建立 `POST /api/upload` 路由，並應用 `multer` 中介軟體。核心邏輯是根據通話唯一識別碼（callId）判斷並只儲存第一個到達的檔案，後續對相同 callId 的上傳請求將被拒絕。",
            "dependencies": [
              8.1
            ],
            "details": "在 `multer` 的設定中，使用 `fileFilter` 選項來實現此邏輯。在 `fileFilter` 函式中，根據從請求中獲取的 `callId`，使用 `fs.existsSync()` 檢查目標檔案（例如 `./uploads/${callId}.wav`）是否已存在。如果檔案已存在，則呼叫回呼函式 `cb(new Error('檔案已存在'), false)` 來拒絕上傳。如果不存在，則呼叫 `cb(null, true)` 接受檔案。接著，在 Express 中建立 `POST /api/upload` 路由，並將此 multer 實例作為中介軟體。",
            "status": "done",
            "testStrategy": "使用 Postman，對同一個 `callId` 連續發送兩次檔案上傳請求。驗證第一次請求成功（HTTP 200），且檔案被儲存。驗證第二次請求失敗（例如 HTTP 409 Conflict 或 400 Bad Request），且檔案系統中沒有新的檔案或覆蓋舊檔案。"
          },
          {
            "id": 3,
            "title": "將成功上傳的檔案路徑更新至資料庫",
            "description": "當檔案根據「首次上傳」邏輯被成功儲存後，將該檔案在伺服器上的相對路徑或可供存取的 URL 更新到 `call_history` 資料庫表格中對應的紀錄。",
            "dependencies": [
              8.2
            ],
            "details": "在 `POST /api/upload` 路由的處理器中，當 `multer` 中介軟體成功執行後（即檔案已儲存），從 `req.file` 物件中獲取檔案路徑（`req.file.path`）。使用資料庫操作工具（如 Sequelize, Knex 或原生驅動），執行一個 `UPDATE` 查詢，例如：`UPDATE call_history SET audio_url = ? WHERE call_id = ?`。將檔案路徑和從 `req.body.callId` 獲取的通話 ID 作為參數傳入。",
            "status": "done",
            "testStrategy": "先確保資料庫中有一筆特定 `callId` 的紀錄且 `audio_url` 為 NULL。接著透過 Postman 上傳該 `callId` 的錄音檔。上傳成功後，查詢資料庫，驗證該筆紀錄的 `audio_url` 欄位是否已更新為正確的檔案路徑（例如 `uploads/your-call-id.wav`）。"
          },
          {
            "id": 4,
            "title": "建立檔案下載路由 (GET /api/download/:callId)",
            "description": "建立一個 `GET /api/download/:callId` 的 API 端點。此端點將根據 URL 路徑中的 `callId` 參數，從資料庫中查詢對應的檔案路徑。",
            "dependencies": [
              8.3
            ],
            "details": "在 Express 中定義一個新的 GET 路由 `router.get('/download/:callId', async (req, res) => { ... })`。在路由處理器中，從 `req.params` 中獲取 `callId`。使用此 `callId` 查詢 `call_history` 表格以取得 `audio_url` 欄位的值。如果找不到紀錄或 `audio_url` 為空，則回傳 404 Not Found。如果找到路徑，則將其儲存以供下一步使用。",
            "status": "done",
            "testStrategy": "在成功上傳一個檔案後，使用 Postman 或 curl 請求 `GET /api/download/[callId]`。在此階段，只需驗證路由能正確從資料庫中讀取到檔案路徑並在伺服器端日誌中印出，或回傳一個包含路徑的 JSON。測試一個不存在的 `callId`，確認伺服器回傳 404。"
          },
          {
            "id": 5,
            "title": "實現檔案下載功能並處理錯誤",
            "description": "在下載路由中，使用 Express 的 `res.download()` 方法將查詢到的檔案作為附件傳送給客戶端，並妥善處理檔案不存在等錯誤情況。",
            "dependencies": [
              8.4
            ],
            "details": "基於上一步驟獲取的檔案路徑，呼叫 `res.download(filePath, (err) => { ... })`。`filePath` 應為完整的伺服器本地路徑。在 `res.download` 的回呼函式中，檢查 `err` 物件。如果發生錯誤（例如檔案在檔案系統中被刪除），記錄錯誤並向客戶端發送 500 Internal Server Error 或 404 Not Found 的錯誤訊息，避免伺服器崩潰。",
            "status": "done",
            "testStrategy": "使用瀏覽器直接訪問 `https://localhost:PORT/api/download/[callId]`。驗證瀏覽器是否觸發檔案下載，且下載的檔案與先前上傳的檔案一致。手動刪除 `uploads` 目錄中的某個檔案，然後再次請求下載該檔案，確認伺服器回傳了適當的錯誤狀態碼（如 404），而不是崩潰。"
          },
          {
            "id": 6,
            "title": "實作 `GET /api/history` 路由以查詢通話紀錄",
            "description": "建立一個 RESTful API 端點，用於查詢 `call_history` 資料庫表格，並關聯 `users` 表以獲取使用者名稱，最後回傳完整的通話紀錄列表。",
            "dependencies": [
              2
            ],
            "details": "建立 `GET /api/history` 路由。在處理器中，執行一條 SQL 查詢，使用 `LEFT JOIN` 將 `call_history` 與 `users` 表格進行兩次關聯（一次用於 `caller_id`，一次用於 `receiver_id`）來獲取發起者和接收者的名稱。將查詢結果格式化為 JSON 陣列並回傳給客戶端。",
            "status": "done",
            "testStrategy": "在資料庫中手動插入幾條通話紀錄後，使用 Postman 或瀏覽器訪問 `/api/history` 端點。驗證回傳的 JSON 陣列是否包含所有紀錄，且每條紀錄都正確地顯示了發起者和接收者的名稱，而不僅僅是 ID。"
          }
        ]
      },
      {
        "id": 9,
        "title": "前端檔案上傳：將錄音檔發送至後端",
        "description": "在前端實現錄音檔案的自動上傳邏輯。通話結束且 `MediaRecorder` 產生音訊 Blob 後，將其作為檔案透過 `fetch` API 發送到後端的 `/upload` 端點。",
        "details": "在 `MediaRecorder` 的 `onstop` 事件處理器中，將產生的 `Blob` 物件封裝到 `FormData` 中，並透過 `fetch` API 以 POST 請求發送。",
        "testStrategy": "進行一次完整的通話並掛斷。在瀏覽器開發者工具的 Network 分頁中，監控是否有一個 POST 請求發往 `/upload`。檢查該請求的 payload 是否包含音訊檔案數據。同時，檢查後端伺服器日誌，確認檔案是否成功接收並儲存。",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "建立專門的錄音檔上傳服務函式",
            "description": "將檔案上傳的 fetch 邏輯從 `useWebRTC.ts` 的 `onstop` 事件處理器中抽離，封裝成一個獨立的、可重用的非同步函式 `uploadRecording`。此函式應接收 `audioBlob` 和 `callId` 作為參數，以提高程式碼的模組化與可測試性。",
            "dependencies": [],
            "details": "在專案中建立一個新檔案，例如 `src/services/api.ts` 或 `src/services/uploadService.ts`。在其中定義並導出一個名為 `uploadRecording` 的非同步函式。此函式簽名應為 `async (audioBlob: Blob, callId: string): Promise<Response>`。將任務描述中提供的 `FormData` 建立和 `fetch` 呼叫邏輯完整地移動到這個新函式內，並返回 `fetch` 的 Promise。",
            "status": "done",
            "testStrategy": "為 `uploadRecording` 函式編寫單元測試。使用 Jest 等測試框架，並模擬 `fetch` API。驗證函式在被呼叫時，是否能用正確的 `audioBlob` 和 `callId` 建構 `FormData`，並以 `POST` 方法向 `/upload` 端點發起請求。"
          },
          {
            "id": 2,
            "title": "在 useWebRTC Hook 中加入上傳狀態管理",
            "description": "為了在 UI 上能即時反映檔案上傳的進度、成功或失敗，需要在 `useWebRTC.ts` 這個 React Hook 中使用 `useState` 來定義並管理上傳的相關狀態。",
            "dependencies": [],
            "details": "在 `useWebRTC.ts` Hook 的頂部，使用 `useState` 宣告以下三個狀態：\n1. `const [isUploading, setIsUploading] = useState<boolean>(false);` 用於追蹤是否正在上傳。\n2. `const [uploadSuccess, setUploadSuccess] = useState<boolean | null>(null);` 用於表示上傳成功或失敗。\n3. `const [uploadError, setUploadError] = useState<string | null>(null);` 用於儲存上傳失敗時的錯誤訊息。",
            "status": "done",
            "testStrategy": "此為內部狀態變更，可在後續整合測試中，透過 React DevTools 檢查 `useWebRTC` Hook 的狀態值是否如預期在不同階段（開始上傳、上傳成功、上傳失敗）進行更新。"
          },
          {
            "id": 3,
            "title": "整合上傳服務至 MediaRecorder 的 onstop 事件",
            "description": "修改 `useWebRTC.ts` 中的 `mediaRecorder.onstop` 事件處理器。在 `MediaRecorder` 停止錄製並產生音訊 `Blob` 後，呼叫先前建立的 `uploadRecording` 服務函式，並根據其執行結果更新上傳狀態。",
            "dependencies": [
              9.1,
              9.2
            ],
            "details": "在 `mediaRecorder.onstop` 的非同步處理函式中，首先呼叫 `setIsUploading(true)`、`setUploadSuccess(null)` 和 `setUploadError(null)` 來重置狀態。然後，在一個 `try...catch` 區塊中，`await` 呼叫從服務檔案中匯入的 `uploadRecording(audioBlob, currentCallId)`。在 `try` 區塊的成功路徑中，檢查回傳的 `response.ok`，若為真則呼叫 `setUploadSuccess(true)`，否則拋出一個錯誤。在 `catch` 區塊中，捕獲錯誤，呼叫 `setUploadSuccess(false)` 並使用 `setUploadError` 記錄錯誤訊息。最後，在 `finally` 區塊中呼叫 `setIsUploading(false)`。",
            "status": "done",
            "testStrategy": "進行一次完整的通話並掛斷。在瀏覽器開發者工具的 Network 分頁中，監控是否有一個 POST 請求發往 `/upload`。同時，使用 React DevTools 觀察 `useWebRTC` Hook 的 `isUploading`, `uploadSuccess` 狀態是否從 `true, null` 變為 `false, true`（或 `false, false` 如果失敗）。"
          },
          {
            "id": 4,
            "title": "實作詳細的錯誤處理與回饋",
            "description": "增強上傳失敗時的錯誤處理邏輯。不僅僅是設定狀態，還要能解析後端可能回傳的 JSON 錯誤訊息，並將其提供給 UI 層顯示，以幫助使用者或開發者理解問題所在。",
            "dependencies": [
              9.3
            ],
            "details": "修改 `mediaRecorder.onstop` 處理器中的 `try...catch` 邏輯。當 `fetch` 的 `response.ok` 為 `false` 時，嘗試 `await response.json()` 來解析後端回傳的錯誤內容（例如 `{ message: 'Invalid callId' }`）。將解析出的錯誤訊息字串傳遞給 `setUploadError`。如果解析 JSON 失敗，則將 `response.statusText` 作為備用錯誤訊息。這樣可以提供比通用「上傳失敗」更具體的錯誤資訊。",
            "status": "done",
            "testStrategy": "與後端協作或手動修改後端程式碼，使其在特定條件下（例如，無效的 `callId`）回傳一個帶有錯誤訊息的 4xx 或 5xx 回應。觸發此錯誤條件，並檢查前端是否能正確捕獲、解析並將詳細的錯誤訊息設定到 `uploadError` 狀態中。"
          },
          {
            "id": 5,
            "title": "在 UI 元件中顯示上傳狀態與反饋",
            "description": "將 `useWebRTC` Hook 中管理的 `isUploading`, `uploadSuccess`, `uploadError` 狀態連接到相關的 React UI 元件（如 `CallView.tsx` 或一個新的 `StatusIndicator.tsx`），向使用者提供關於錄音上傳進度的即時視覺反饋。",
            "dependencies": [
              9.2,
              9.4
            ],
            "details": "從 `useWebRTC` Hook 的回傳物件中導出 `isUploading`, `uploadSuccess`, `uploadError`。在負責顯示通話後介面的 React 元件中，使用這些狀態進行條件渲染。\n- 當 `isUploading` 為 `true` 時，顯示一個載入動畫或文字，例如「錄音上傳中...」。\n- 當 `isUploading` 為 `false` 且 `uploadSuccess` 為 `true` 時，顯示成功訊息，例如「錄音已儲存」。\n- 當 `uploadSuccess` 為 `false` 時，顯示 `uploadError` 狀態中儲存的錯誤訊息，並可選擇提供一個重試按鈕。",
            "status": "done",
            "testStrategy": "手動測試整個通話到上傳的流程。視覺上確認：1. 掛斷電話後，出現「上傳中...」的指示器。2. 上傳成功後，指示器變為成功訊息。3. 模擬上傳失敗（例如中斷網路連線或使用無效的後端端點），確認 UI 上顯示了正確的錯誤訊息。"
          }
        ]
      },
      {
        "id": 10,
        "title": "前端監控中心：通話紀錄查詢與即時上線人員列表",
        "description": "建立「VoIP 通話監控中心」頁面，此頁面包含兩大功能：一是從後端 API 獲取並顯示歷史通話紀錄，並提供下載連結；二是透過 WebSocket 即時顯示當前線上人員名單。",
        "details": "建立一個新的 React 元件/頁面，例如 `MonitorPage.tsx`。在該元件中，使用 `useEffect` 向後端的 `/api/history` 端點發請求以獲取通話紀錄。同時，建立一個 WebSocket 連線來接收 `user-list` 訊息。將獲取的數據儲存在 `useState` 中，並分別渲染成通話紀錄表格和線上人員列表。",
        "testStrategy": "導航到監控頁面。驗證頁面是否成功渲染了通話列表和線上人員列表。點擊下載連結確認能下載檔案。打開新客戶端連線，確認線上人員列表即時更新。",
        "priority": "low",
        "dependencies": [
          3,
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "建立監控中心頁面元件與路由設定",
            "description": "建立新的 React 元件檔案 `src/pages/MonitorPage.tsx`，並在應用程式的路由設定中新增一條路由規則，將 `/monitor` 路徑對應到此新元件。",
            "dependencies": [],
            "details": "1. 在 `src/pages/` 目錄下建立 `MonitorPage.tsx` 檔案。\n2. 在檔案中建立一個基本的 React 函式元件，返回包含「通話紀錄」和「上線人員名單」兩個區塊的佈局。\n3. 在主要的路由設定檔（如 `App.tsx` 或 `routes.tsx`）中，匯入 `MonitorPage` 元件並設定路由。",
            "status": "done",
            "testStrategy": "啟動應用程式後，手動在瀏覽器網址列輸入 `/monitor`。驗證頁面是否成功跳轉並顯示兩個區塊的標題。"
          },
          {
            "id": 2,
            "title": "實作 API 請求以獲取通話紀錄",
            "description": "在 `MonitorPage.tsx` 元件中，使用 `useEffect` hook 在元件掛載時向後端 `GET /api/history` 端點發送請求，並管理數據、載入和錯誤狀態。",
            "dependencies": [
              10.1,
              8.6
            ],
            "details": "1. 定義一個 TypeScript interface 來描述單筆通話紀錄的資料結構。\n2. 使用 `useState` 建立 `records`, `isLoading`, `error` 狀態。\n3. 在 `useEffect` 中，使用 `fetch` 或 `axios` 呼叫 `/api/history` API，並在 `try/catch/finally` 區塊中處理 API 回應。",
            "status": "done",
            "testStrategy": "在瀏覽器開發者工具的 Network 分頁中，檢查是否有向 `/api/history` 發出的 GET 請求。使用 `console.log` 驗證從 API 收到的數據是否成功存入 `records` 狀態中。"
          },
          {
            "id": 3,
            "title": "使用表格渲染通話紀錄數據與下載連結",
            "description": "根據獲取的通話紀錄數據，動態渲染一個包含下載連結的 HTML 表格。",
            "dependencies": [
              10.2
            ],
            "details": "1. 在 JSX 中建立一個 `<table>` 結構。\n2. 在 `<tbody>` 中，使用 `records.map()` 方法來遍歷通話紀錄陣列。\n3. 為每筆 `record` 渲染一個 `<tr>`，並在最後一欄的 `<td>` 中，建立一個 `href` 指向 `/api/download/${record.callId}` 的下載連結 `<a>` 標籤。",
            "status": "done",
            "testStrategy": "驗證頁面是否能正確渲染出包含數據的表格。點擊下載連結，確認瀏覽器觸發檔案下載操作。"
          },
          {
            "id": 4,
            "title": "新增載入中、錯誤及無資料狀態的 UI 處理",
            "description": "優化使用者體驗，為通話紀錄區塊添加不同的狀態顯示：載入中、請求失敗、無資料。",
            "dependencies": [
              10.2
            ],
            "details": "在 JSX 的渲染邏輯中，使用條件渲染。`if (isLoading)` 顯示載入指示器；`if (error)` 顯示錯誤訊息；`if (!isLoading && records.length === 0)` 顯示「暫無通話紀錄」。",
            "status": "done",
            "testStrategy": "1. 透過在 API 請求中手動引入延遲來測試載入狀態。2. 故意將 API URL 改錯，驗證錯誤訊息是否顯示。3. 讓後端 API 返回一個空陣列，驗證「暫無通話紀錄」的提示是否正確顯示。"
          },
          {
            "id": 5,
            "title": "在監控頁面建立 WebSocket 連線",
            "description": "讓「通話監控中心」頁面也具備 WebSocket 連線能力，以便接收來自伺服器的即時訊息，特別是線上使用者列表。",
            "dependencies": [
              10.1,
              3
            ],
            "details": "在 `MonitorPage.tsx` 中，使用 `useEffect` hook 來建立和管理一個 WebSocket 連線。連線成功後，可以選擇性地向伺服器發送一個識別訊息，表明自己是監控中心客戶端。",
            "status": "done",
            "testStrategy": "載入監控頁面後，在瀏覽器 Network 分頁確認 WebSocket 連線已成功建立。在後端伺服器日誌中應能看到一個新的客戶端連線。"
          },
          {
            "id": 6,
            "title": "實作並顯示即時「上線人員名單」",
            "description": "監聽來自 WebSocket 的 `user-list` 訊息，並將即時的線上使用者列表渲染在頁面上，實現 PRD 中描述的監控功能。",
            "dependencies": [
              10.5
            ],
            "details": "1. 使用 `useState` 建立 `onlineUsers` 狀態。\n2. 在 WebSocket 的 `onmessage` 事件處理器中，檢查訊息類型是否為 `user-list`。\n3. 如果是，則使用伺服器傳來的用戶列表更新 `onlineUsers` 狀態。\n4. 在 JSX 的「上線人員名單」區塊中，使用 `onlineUsers.map()` 將列表渲染成一個表格或列表，顯示使用者名稱、IP 位址等資訊。",
            "status": "done",
            "testStrategy": "打開監控頁面。在另一個瀏覽器分頁中，讓一個新使用者連線到主應用。驗證監控頁面上的「上線人員名單」是否幾乎即時地新增了這位使用者。反之，當使用者離線時，列表也應即時更新。"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-11T06:06:25.161Z",
      "updated": "2025-08-11T09:56:25.469Z",
      "description": "Tasks for master context, updated with suggestions."
    }
  }
}